{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Parser.AbsSimpleCalc where

-- Haskell module generated by the BNF converter


import Data.Data (Data,Typeable,cast,toConstr)
import GHC.Generics (Generic)
import Data.Generics.Aliases (mkQ)
import Data.Generics.Schemes (gfindtype)
import Data.Generics.Twins (gzipWithQ)
import Data.Maybe (fromJust)

class Typed a where
  getType :: a -> Type

newtype Identifier = Identifier ((Int,Int),String)
  deriving (Show, Read, Data, Typeable, Generic)

instance Eq Identifier where
  (Identifier (_, x)) == (Identifier (_, y)) = x == y

instance Ord Identifier where
  compare (Identifier (_, x)) (Identifier (_, y)) = compare x y

newtype Lambda = Lambda String
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)
data TypeVar = TypeVar Identifier
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

data Type
    = ArrowT Type Type
    | PlusT Type Type
    | TimesT Type Type
    | LfpT Identifier Type
    | GfpT Identifier Type
    | OneT
    | VarT TypeVar
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

data Term a
    = Var a Identifier
    | Unit a
    | Inl a (Term a)
    | Inr a (Term a)
    | Pair a (Term a) (Term a)
    | Abs a Lambda Identifier (Term a)
    | In a (Term a)
    | App a (Term a) (Term a)
    | Fst a (Term a)
    | Snd a (Term a)
    | Out a (Term a)
    | Match a Identifier (Term a) Identifier (Term a) (Term a)
    | Rec a (Term a) (Term a)
    | Corec a (Term a) (Term a)
  deriving (Ord, Show, Read, Data, Typeable, Generic, Functor)

mkQ2 :: (Typeable a1, Typeable a2, Typeable b)
    => r
    -> (b -> b -> r)
    -> a1 -> a2
    -> r
(r `mkQ2` br) a1 a2 =
  case cast a1 of
   Just b1 -> case cast a2 of
     Just b2 -> br b1 b2
     Nothing -> r
   Nothing -> r

instance forall a. Data a => Eq (Term a) where
  (==) = eq'
    where
      eq' :: Term a -> Term a -> Bool
      eq' (Var _ x) (Var _ y) = x == y
      eq' s t =
        (toConstr s == toConstr t)
        && and (gzipWithQ (True `mkQ2` eq') s t)

type TTerm = Term Type

instance Typed (Term Type) where
  getType = fromJust . gfindtype

forgetType :: TTerm -> Term ()
forgetType = fmap (\_ -> ())

data PropDecl = PropDecl Identifier Type
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

data PropDecls = NoPropDecls | PropDecls [PropDecl]
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

data PropArg a = PropArg (Term a)
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

type TPropArg = PropArg Type

data PropArgs a = NoPropArgs | PropArgs [PropArg a]
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

type TPropArgs = PropArgs Type

data Formula a
    = Bottom
    | PropVar Identifier (PropArgs a)
    | Implies (Formula a) (Formula a)
    | Or (Formula a) (Formula a)
    | And (Formula a) (Formula a)
    | Forall Identifier Type (Formula a)
    | Exists Identifier Type (Formula a)
    | EqForm (Equality a)
    | Later (Formula a)
    | LfpF Identifier PropDecls (Formula a)
    | GfpF Identifier PropDecls (Formula a)
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

type TFormula = Formula Type

data Equality a = Equality (Term a) (Term a)
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

type TEquality = Equality Type

data ThmArg a = ThmArg (Formula a)
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

type TThmArg = ThmArg Type

data ThmArgs a = NoArgs | Args [ThmArg a]
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

type TThmArgs = ThmArgs Type

data Proof a
    = PrHole
    | PrVar Identifier
    | PrBotElim (Proof a)
    | PrThmInst Identifier (ThmArgs a)
    | PrImplIntro Lambda Identifier (Proof a)
    | PrImplElim (Proof a) (Proof a)
    | PrAndIntro (Proof a) (Proof a)
    | PrAndElimFst (Proof a)
    | PrAndElimSnd (Proof a)
    | PrOrIntroLeft (Proof a)
    | PrOrIntroRight (Proof a)
    | PrOrElim (Proof a) (Proof a)
    | PrNec (Proof a)
    | PrAppl (Proof a) (Proof a)
    | PrFP Identifier (Proof a)
    | PrAllIntro Identifier (Proof a)
    | PrAllElim (Proof a) (Term a)
    | PrExIntro (Term a) (Proof a)
    | PrExElim Identifier (Proof a) (Proof a)
    | PrRefl (Term a) (Term a)
    | PrSym (Proof a)
    | PrTrans (Proof a) (Proof a)
    | PrExt Identifier (Proof a)
    | PrFunEq (Proof a) (Term a)
    | PrUnit (Term a)
    | PrFst (Proof a)
    | PrSnd (Proof a)
    | PrPair (Proof a) (Proof a)
    | PrOut (Proof a)
    | PrCoind (Proof a)
    | PrUnitInd (Proof a) Identifier
    | PrInl (Proof a)
    | PrInr (Proof a)
    | PrSumInd Identifier (Proof a) Identifier (Proof a) Identifier
    | PrIn (Proof a)
    | PrLfpInd Identifier (Proof a) Identifier
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

type TProof = Proof Type

data ThmDecl = ThmDecl Identifier PropDecls
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

data ThmDecls = NoDeclArgs | DeclArgs [ThmDecl]
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

data Entry a
    = TypeDef Identifier Type
    | Def Identifier Type (Term a)
    | Theorem Identifier ThmDecls (Formula a) (Proof a)
    | FormDef Identifier ThmDecls (Formula a)
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

type TEntry = Entry Type

data Program a = Program [Entry a]
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

type TProgram = Program Type
