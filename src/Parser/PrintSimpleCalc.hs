{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}
module Parser.PrintSimpleCalc where

-- pretty-printer generated by the BNF converter

import Parser.AbsSimpleCalc
import Data.Char


-- the top-level printing method
printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["      :ts -> showChar '[' . rend i ts
    "("      :ts -> showChar '(' . rend i ts
    "{"      :ts -> showChar '{' . new (i+1) . rend (i+1) ts
    "}" : ";":ts -> new (i-1) . space "}" . showChar ';' . new (i-1) . rend (i-1) ts
    "}"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts
    ";"      :ts -> showChar ';' . new i . rend i ts
    t  : "," :ts -> showString t . space "," . rend i ts
    t  : ")" :ts -> showString t . showChar ')' . rend i ts
    t  : "]" :ts -> showString t . showChar ']' . rend i ts
    t        :ts -> space t . rend i ts
    _            -> id
  new i   = showChar '\n' . replicateS (2*i) (showChar ' ') . dropWhile isSpace
  space t = showString t . (\s -> if null s then "" else (' ':s))

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- the printer class does the job
class Print a where
  prt :: Int -> a -> Doc
  prtList :: Int -> [a] -> Doc
  prtList i = concatD . map (prt i)

instance Print a => Print [a] where
  prt = prtList

instance Print Char where
  prt _ s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList _ s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j<i then parenth else id


instance Print Integer where
  prt _ x = doc (shows x)


instance Print Double where
  prt _ x = doc (shows x)



instance Print Identifier where
  prt _ (Identifier (_,i)) = doc (showString ( i))


instance Print Lambda where
  prt _ (Lambda i) = doc (showString ( i))



instance Print TypeVar where
  prt i e = case e of
    TypeVar identifier -> prPrec i 0 (concatD [prt 0 identifier])

instance Print Type where
  prt i e = case e of
    ArrowT type_1 type_2 -> prPrec i 0 (concatD [prt 1 type_1, doc (showString "->"), prt 0 type_2])
    PlusT type_1 type_2 -> prPrec i 1 (concatD [prt 1 type_1, doc (showString "+"), prt 2 type_2])
    TimesT type_1 type_2 -> prPrec i 2 (concatD [prt 2 type_1, doc (showString "*"), prt 3 type_2])
    LfpT identifier type_ -> prPrec i 0 (concatD [doc (showString "lfp"), prt 0 identifier, doc (showString "."), prt 0 type_])
    GfpT identifier type_ -> prPrec i 0 (concatD [doc (showString "gfp"), prt 0 identifier, doc (showString "."), prt 0 type_])
    OneT -> prPrec i 3 (concatD [doc (showString "Unit")])
    VarT typevar -> prPrec i 3 (concatD [prt 0 typevar])

instance Print (Term a) where
  prt i e = case e of
    Var _ identifier -> prPrec i 3 (concatD [prt 0 identifier])
    Unit _ -> prPrec i 3 (concatD [doc (showString "<>")])
    Inl _ term -> prPrec i 0 (concatD [doc (showString "inl"), prt 1 term])
    Inr _ term -> prPrec i 0 (concatD [doc (showString "inr"), prt 1 term])
    Pair _ term1 term2 -> prPrec i 3 (concatD [doc (showString "<"), prt 0 term1, doc (showString ","), prt 0 term2, doc (showString ">")])
    Abs _ lambda identifier term -> prPrec i 0 (concatD [prt 0 lambda, prt 0 identifier, doc (showString "."), prt 0 term])
    In _ term -> prPrec i 0 (concatD [doc (showString "in"), prt 1 term])
    App _ term1 term2 -> prPrec i 2 (concatD [prt 2 term1, prt 3 term2])
    Fst _ term -> prPrec i 2 (concatD [prt 1 term, doc (showString ".fst")])
    Snd _ term -> prPrec i 2 (concatD [prt 1 term, doc (showString ".snd")])
    Out _ term -> prPrec i 2 (concatD [prt 1 term, doc (showString ".out")])
    Match _ identifier1 term1 identifier2 term2 term3 -> prPrec i 0 (concatD [doc (showString "{"), doc (showString "inl"), prt 0 identifier1, doc (showString "->"), prt 0 term1, doc (showString ";"), doc (showString "inr"), prt 0 identifier2, doc (showString "->"), prt 0 term2, doc (showString "}"), prt 3 term3])
    Rec _ term1 term2 -> prPrec i 2 (concatD [doc (showString "rec"), prt 3 term1, prt 3 term2])
    Corec _ term1 term2 -> prPrec i 2 (concatD [doc (showString "corec"), prt 3 term1, prt 3 term2])

instance Print PropDecl where
  prt i e = case e of
    PropDecl identifier type_ -> prPrec i 0 (concatD [prt 0 identifier, doc (showString ":"), prt 0 type_])
  prtList _ [x] = (concatD [prt 0 x])
  prtList _ (x:xs) = (concatD [prt 0 x, doc (showString ","), prt 0 xs])
instance Print PropDecls where
  prt i e = case e of
    NoPropDecls -> prPrec i 0 (concatD [])
    PropDecls propdecls -> prPrec i 0 (concatD [doc (showString "("), prt 0 propdecls, doc (showString ")")])

instance Print (PropArg a) where
  prt i e = case e of
    PropArg term -> prPrec i 0 (concatD [prt 0 term])
  prtList _ [x] = (concatD [prt 0 x])
  prtList _ (x:xs) = (concatD [prt 0 x, doc (showString ","), prt 0 xs])
instance Print (PropArgs a) where
  prt i e = case e of
    NoPropArgs -> prPrec i 0 (concatD [])
    PropArgs propargs -> prPrec i 0 (concatD [doc (showString "("), prt 0 propargs, doc (showString ")")])

instance Print (Formula a) where
  prt i e = case e of
    Bottom -> prPrec i 4 (concatD [doc (showString "F")])
    PropVar identifier propargs -> prPrec i 4 (concatD [prt 0 identifier, prt 0 propargs])
    Implies formula1 formula2 -> prPrec i 0 (concatD [prt 1 formula1, doc (showString "->"), prt 0 formula2])
    Or formula1 formula2 -> prPrec i 1 (concatD [prt 1 formula1, doc (showString "|"), prt 2 formula2])
    And formula1 formula2 -> prPrec i 2 (concatD [prt 2 formula1, doc (showString "&"), prt 3 formula2])
    Forall identifier type_ formula -> prPrec i 0 (concatD [doc (showString "forall"), prt 0 identifier, doc (showString ":"), prt 0 type_, doc (showString "."), prt 0 formula])
    Exists identifier type_ formula -> prPrec i 0 (concatD [doc (showString "exists"), prt 0 identifier, doc (showString ":"), prt 0 type_, doc (showString "."), prt 0 formula])
    EqForm equality -> prPrec i 3 (concatD [prt 0 equality])
    Later formula -> prPrec i 3 (concatD [doc (showString "#"), prt 4 formula])
    LfpF identifier propdecls formula -> prPrec i 0 (concatD [doc (showString "lfp"), prt 0 identifier, prt 0 propdecls, doc (showString "."), prt 0 formula])
    GfpF identifier propdecls formula -> prPrec i 0 (concatD [doc (showString "gfp"), prt 0 identifier, prt 0 propdecls, doc (showString "."), prt 0 formula])

instance Print (Equality a) where
  prt i e = case e of
    Equality term1 term2 -> prPrec i 1 (concatD [prt 0 term1, doc (showString "~"), prt 0 term2])

instance Print (ThmArg a) where
  prt i e = case e of
    ThmArg formula -> prPrec i 0 (concatD [prt 0 formula])
  prtList _ [] = (concatD [])
  prtList _ [x] = (concatD [prt 0 x])
  prtList _ (x:xs) = (concatD [prt 0 x, doc (showString ","), prt 0 xs])
instance Print (ThmArgs a) where
  prt i e = case e of
    NoArgs -> prPrec i 0 (concatD [])
    Args thmargs -> prPrec i 0 (concatD [doc (showString "["), prt 0 thmargs, doc (showString "]")])

instance Print (Proof a) where
  prt i e = case e of
    PrHole -> prPrec i 4 (concatD [doc (showString "??")])
    PrVar identifier -> prPrec i 4 (concatD [prt 0 identifier])
    PrBotElim proof -> prPrec i 2 (concatD [doc (showString "bot-elim"), prt 1 proof])
    PrThmInst identifier thmargs -> prPrec i 0 (concatD [doc (showString "inst"), prt 0 identifier, prt 0 thmargs])
    PrImplIntro lambda identifier proof -> prPrec i 0 (concatD [prt 0 lambda, prt 0 identifier, doc (showString "."), prt 0 proof])
    PrImplElim proof1 proof2 -> prPrec i 3 (concatD [prt 3 proof1, prt 4 proof2])
    PrAndIntro proof1 proof2 -> prPrec i 4 (concatD [doc (showString "<"), prt 0 proof1, doc (showString "&"), prt 0 proof2, doc (showString ">")])
    PrAndElimFst proof -> prPrec i 2 (concatD [prt 1 proof, doc (showString ".&fst")])
    PrAndElimSnd proof -> prPrec i 2 (concatD [prt 1 proof, doc (showString ".&snd")])
    PrOrIntroLeft proof -> prPrec i 0 (concatD [doc (showString "|inl"), prt 1 proof])
    PrOrIntroRight proof -> prPrec i 0 (concatD [doc (showString "|inr"), prt 1 proof])
    PrOrElim proof1 proof2 -> prPrec i 0 (concatD [doc (showString "|-elim"), prt 4 proof1, prt 4 proof2])
    PrNec proof -> prPrec i 0 (concatD [doc (showString "nec"), prt 1 proof])
    PrAppl proof1 proof2 -> prPrec i 2 (concatD [prt 2 proof1, doc (showString "<*>"), prt 3 proof2])
    PrFP identifier proof -> prPrec i 0 (concatD [doc (showString "fix"), prt 0 identifier, doc (showString "."), prt 0 proof])
    PrAllIntro identifier proof -> prPrec i 0 (concatD [doc (showString "\\\\"), prt 0 identifier, doc (showString "."), prt 0 proof])
    PrAllElim proof term -> prPrec i 2 (concatD [prt 2 proof, doc (showString "@"), prt 3 term])
    PrExIntro term proof -> prPrec i 0 (concatD [doc (showString "ex"), prt 3 term, prt 1 proof])
    PrExElim identifier proof1 proof2 -> prPrec i 0 (concatD [doc (showString "ex-elim"), prt 0 identifier, prt 4 proof1, prt 4 proof2])
    PrRefl term1 term2 -> prPrec i 0 (concatD [doc (showString "refl"), prt 3 term1, prt 3 term2])
    PrSym proof -> prPrec i 0 (concatD [doc (showString "sym"), prt 4 proof])
    PrTrans proof1 proof2 -> prPrec i 0 (concatD [doc (showString "trans"), prt 4 proof1, prt 4 proof2])
    PrExt identifier proof -> prPrec i 0 (concatD [doc (showString "ext"), prt 0 identifier, prt 0 proof])
    PrFunEq proof term -> prPrec i 0 (concatD [doc (showString "fun"), prt 1 proof, prt 3 term])
    PrUnit term -> prPrec i 0 (concatD [doc (showString "unit"), prt 3 term])
    PrFst proof -> prPrec i 2 (concatD [prt 1 proof, doc (showString ".fst")])
    PrSnd proof -> prPrec i 2 (concatD [prt 1 proof, doc (showString ".snd")])
    PrPair proof1 proof2 -> prPrec i 4 (concatD [doc (showString "<"), prt 0 proof1, doc (showString ","), prt 0 proof2, doc (showString ">")])
    PrOut proof -> prPrec i 2 (concatD [prt 1 proof, doc (showString ".out")])
    PrCoind proof -> prPrec i 0 (concatD [doc (showString "coind"), prt 1 proof])
    PrUnitInd proof identifier -> prPrec i 0 (concatD [doc (showString "{"), doc (showString "<>"), doc (showString "->"), prt 0 proof, doc (showString "}"), prt 0 identifier])
    PrInl proof -> prPrec i 0 (concatD [doc (showString "inl"), prt 1 proof])
    PrInr proof -> prPrec i 0 (concatD [doc (showString "inr"), prt 1 proof])
    PrSumInd identifier1 proof1 identifier2 proof2 identifier3 -> prPrec i 0 (concatD [doc (showString "{"), doc (showString "inl"), prt 0 identifier1, doc (showString "->"), prt 0 proof1, doc (showString ";"), doc (showString "inr"), prt 0 identifier2, doc (showString "->"), prt 0 proof2, doc (showString "}"), prt 0 identifier3])
    PrIn proof -> prPrec i 0 (concatD [doc (showString "in"), prt 1 proof])
    PrLfpInd identifier1 proof identifier2 -> prPrec i 0 (concatD [doc (showString "{"), doc (showString "in"), prt 0 identifier1, doc (showString "->"), prt 0 proof, doc (showString "}"), prt 0 identifier2])

instance Print ThmDecl where
  prt i e = case e of
    ThmDecl identifier propdecls -> prPrec i 0 (concatD [prt 0 identifier, prt 0 propdecls])
  prtList _ [] = (concatD [])
  prtList _ [x] = (concatD [prt 0 x])
  prtList _ (x:xs) = (concatD [prt 0 x, doc (showString ","), prt 0 xs])
instance Print ThmDecls where
  prt i e = case e of
    NoDeclArgs -> prPrec i 0 (concatD [])
    DeclArgs thmdecls -> prPrec i 0 (concatD [doc (showString "["), prt 0 thmdecls, doc (showString "]")])

instance Print (Entry a) where
  prt i e = case e of
    TypeDef identifier type_ -> prPrec i 0 (concatD [doc (showString "type"), prt 0 identifier, doc (showString "="), prt 0 type_])
    Def identifier type_ term -> prPrec i 0 (concatD [prt 0 identifier, doc (showString ":"), prt 0 type_, doc (showString "="), prt 0 term])
    Theorem identifier thmdecls formula proof -> prPrec i 0 (concatD [doc (showString "thm"), prt 0 identifier, prt 0 thmdecls, doc (showString ":"), prt 0 formula, doc (showString "="), prt 0 proof])
    FormDef identifier thmdecls formula -> prPrec i 0 (concatD [doc (showString "def"), prt 0 identifier, prt 0 thmdecls, doc (showString "="), prt 0 formula])
  prtList _ [] = (concatD [])
  prtList _ (x:xs) = (concatD [prt 0 x, doc (showString ";"), prt 0 xs])
instance Print (Program a) where
  prt i e = case e of
    Program entrys -> prPrec i 0 (concatD [prt 0 entrys])


