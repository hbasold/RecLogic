-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parser.ParSimpleCalc where
import Parser.AbsSimpleCalc
import Parser.LexSimpleCalc
import Parser.ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '&' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  ',' { PT _ (TS _ 7) }
  '->' { PT _ (TS _ 8) }
  '.' { PT _ (TS _ 9) }
  '.&fst' { PT _ (TS _ 10) }
  '.&snd' { PT _ (TS _ 11) }
  '.fst' { PT _ (TS _ 12) }
  '.out' { PT _ (TS _ 13) }
  '.snd' { PT _ (TS _ 14) }
  ':' { PT _ (TS _ 15) }
  ';' { PT _ (TS _ 16) }
  '<' { PT _ (TS _ 17) }
  '<*>' { PT _ (TS _ 18) }
  '<>' { PT _ (TS _ 19) }
  '=' { PT _ (TS _ 20) }
  '>' { PT _ (TS _ 21) }
  '??' { PT _ (TS _ 22) }
  '@' { PT _ (TS _ 23) }
  'Eq' { PT _ (TS _ 24) }
  'F' { PT _ (TS _ 25) }
  'Unit' { PT _ (TS _ 26) }
  '[' { PT _ (TS _ 27) }
  '\\\\' { PT _ (TS _ 28) }
  ']' { PT _ (TS _ 29) }
  'bot-elim' { PT _ (TS _ 30) }
  'coind' { PT _ (TS _ 31) }
  'corec' { PT _ (TS _ 32) }
  'def' { PT _ (TS _ 33) }
  'ex' { PT _ (TS _ 34) }
  'ex-elim' { PT _ (TS _ 35) }
  'exists' { PT _ (TS _ 36) }
  'ext' { PT _ (TS _ 37) }
  'fix' { PT _ (TS _ 38) }
  'forall' { PT _ (TS _ 39) }
  'fun' { PT _ (TS _ 40) }
  'gfp' { PT _ (TS _ 41) }
  'in' { PT _ (TS _ 42) }
  'inl' { PT _ (TS _ 43) }
  'inr' { PT _ (TS _ 44) }
  'inst' { PT _ (TS _ 45) }
  'lfp' { PT _ (TS _ 46) }
  'nec' { PT _ (TS _ 47) }
  'rec' { PT _ (TS _ 48) }
  'refl' { PT _ (TS _ 49) }
  'sym' { PT _ (TS _ 50) }
  'thm' { PT _ (TS _ 51) }
  'trans' { PT _ (TS _ 52) }
  'type' { PT _ (TS _ 53) }
  'unit' { PT _ (TS _ 54) }
  '{' { PT _ (TS _ 55) }
  '|' { PT _ (TS _ 56) }
  '|-elim' { PT _ (TS _ 57) }
  '|inl' { PT _ (TS _ 58) }
  '|inr' { PT _ (TS _ 59) }
  '}' { PT _ (TS _ 60) }
  '~' { PT _ (TS _ 61) }

L_Identifier { PT _ (T_Identifier _) }
L_Lambda { PT _ (T_Lambda $$) }


%%

Identifier    :: { Identifier} : L_Identifier { Identifier (mkPosToken $1)}
Lambda    :: { Lambda} : L_Lambda { Lambda ($1)}

TypeVar :: { TypeVar }
TypeVar : Identifier { Parser.AbsSimpleCalc.TypeVar $1 }
Type :: { Type }
Type : Type1 '->' Type { Parser.AbsSimpleCalc.ArrowT $1 $3 }
     | 'lfp' Identifier '.' Type { Parser.AbsSimpleCalc.LfpT $2 $4 }
     | 'gfp' Identifier '.' Type { Parser.AbsSimpleCalc.GfpT $2 $4 }
     | Type1 { $1 }
Type1 :: { Type }
Type1 : Type1 '+' Type2 { Parser.AbsSimpleCalc.PlusT $1 $3 }
      | Type2 { $1 }
Type2 :: { Type }
Type2 : Type2 '*' Type3 { Parser.AbsSimpleCalc.TimesT $1 $3 }
      | Type3 { $1 }
Type3 :: { Type }
Type3 : 'Unit' { Parser.AbsSimpleCalc.OneT }
      | TypeVar { Parser.AbsSimpleCalc.VarT $1 }
      | '(' Type ')' { $2 }
Term3 :: { Term () }
Term3 : Identifier { Parser.AbsSimpleCalc.Var () $1 }
      | '<>' { Parser.AbsSimpleCalc.Unit () }
      | '<' Term ',' Term '>' { Parser.AbsSimpleCalc.Pair () $2 $4 }
      | '(' Term ')' { $2 }
Term :: { (Term ()) }
Term : 'inl' Term1 { Parser.AbsSimpleCalc.Inl () $2 }
     | 'inr' Term1 { Parser.AbsSimpleCalc.Inr () $2 }
     | Lambda Identifier '.' Term { Parser.AbsSimpleCalc.Abs () $1 $2 $4 }
     | 'in' Term1 { Parser.AbsSimpleCalc.In () $2 }
     | '{' 'inl' Identifier '->' Term ';' 'inr' Identifier '->' Term '}' Term3 { Parser.AbsSimpleCalc.Match () $3 $5 $8 $10 $12 }
     | Term1 { $1 }
Term2 :: { Term () }
Term2 : Term2 Term3 { Parser.AbsSimpleCalc.App () $1 $2 }
      | Term1 '.fst' { Parser.AbsSimpleCalc.Fst () $1 }
      | Term1 '.snd' { Parser.AbsSimpleCalc.Snd () $1 }
      | Term1 '.out' { Parser.AbsSimpleCalc.Out () $1 }
      | 'rec' Term3 Term3 { Parser.AbsSimpleCalc.Rec () $2 $3 }
      | 'corec' Term3 Term3 { Parser.AbsSimpleCalc.Corec () $2 $3 }
      | Term3 { $1 }
Term1 :: { Term () }
Term1 : Term2 { $1 }
PropDecl :: { PropDecl }
PropDecl : Identifier ':' Type { Parser.AbsSimpleCalc.PropDecl $1 $3 }
PropDecls :: { PropDecls }
PropDecls : {- empty -} { Parser.AbsSimpleCalc.NoPropDecls }
          | '(' ListPropDecl ')' { Parser.AbsSimpleCalc.PropDecls $2 }
ListPropDecl :: { [PropDecl] }
ListPropDecl : PropDecl { (:[]) $1 }
             | PropDecl ',' ListPropDecl { (:) $1 $3 }
PropArg :: { (PropArg ()) }
PropArg : Term { Parser.AbsSimpleCalc.PropArg $1 }
PropArgs :: { (PropArgs ()) }
PropArgs : {- empty -} { Parser.AbsSimpleCalc.NoPropArgs }
         | '(' ListPropArg ')' { Parser.AbsSimpleCalc.PropArgs $2 }
ListPropArg :: { [PropArg ()] }
ListPropArg : PropArg { (:[]) $1 }
            | PropArg ',' ListPropArg { (:) $1 $3 }
Formula4 :: { Formula () }
Formula4 : 'F' { Parser.AbsSimpleCalc.Bottom }
         | Identifier PropArgs { Parser.AbsSimpleCalc.PropVar $1 $2 }
         | '(' Formula ')' { $2 }
Formula :: { (Formula ()) }
Formula : Formula1 '->' Formula { Parser.AbsSimpleCalc.Implies $1 $3 }
        | 'forall' Identifier ':' Type '.' Formula { Parser.AbsSimpleCalc.Forall $2 $4 $6 }
        | 'exists' Identifier ':' Type '.' Formula { Parser.AbsSimpleCalc.Exists $2 $4 $6 }
        | 'lfp' Identifier PropDecls '.' Formula { Parser.AbsSimpleCalc.LfpF $2 $3 $5 }
        | 'gfp' Identifier PropDecls '.' Formula { Parser.AbsSimpleCalc.GfpF $2 $3 $5 }
        | Formula1 { $1 }
Formula1 :: { Formula () }
Formula1 : Formula1 '|' Formula2 { Parser.AbsSimpleCalc.Or $1 $3 }
         | Formula2 { $1 }
Formula2 :: { Formula () }
Formula2 : Formula2 '&' Formula3 { Parser.AbsSimpleCalc.And $1 $3 }
         | Formula3 { $1 }
Formula3 :: { Formula () }
Formula3 : Equality { Parser.AbsSimpleCalc.EqForm $1 }
         | '#' Formula4 { Parser.AbsSimpleCalc.Later $2 }
         | Formula4 { $1 }
Equality1 :: { Equality () }
Equality1 : Term '~' Term { Parser.AbsSimpleCalc.Equality $1 $3 }
Equality :: { (Equality ()) }
Equality : Equality1 { $1 } | 'Eq' Equality1 { $2 }
ThmArg :: { (ThmArg ()) }
ThmArg : Formula { Parser.AbsSimpleCalc.ThmArg $1 }
ThmArgs :: { (ThmArgs ()) }
ThmArgs : {- empty -} { Parser.AbsSimpleCalc.NoArgs }
        | '[' ListThmArg ']' { Parser.AbsSimpleCalc.Args $2 }
ListThmArg :: { [ThmArg ()] }
ListThmArg : {- empty -} { [] }
           | ThmArg { (:[]) $1 }
           | ThmArg ',' ListThmArg { (:) $1 $3 }
Proof4 :: { Proof () }
Proof4 : '??' { Parser.AbsSimpleCalc.PrHole }
       | Identifier { Parser.AbsSimpleCalc.PrVar $1 }
       | '<' Proof '&' Proof '>' { Parser.AbsSimpleCalc.PrAndIntro $2 $4 }
       | '<' Proof ',' Proof '>' { Parser.AbsSimpleCalc.PrPair $2 $4 }
       | '(' Proof ')' { $2 }
Proof2 :: { Proof () }
Proof2 : 'bot-elim' Proof1 { Parser.AbsSimpleCalc.PrBotElim $2 }
       | Proof1 '.&fst' { Parser.AbsSimpleCalc.PrAndElimFst $1 }
       | Proof1 '.&snd' { Parser.AbsSimpleCalc.PrAndElimSnd $1 }
       | Proof2 '<*>' Proof3 { Parser.AbsSimpleCalc.PrAppl $1 $3 }
       | Proof2 '@' Term3 { Parser.AbsSimpleCalc.PrAllElim $1 $3 }
       | Proof1 '.fst' { Parser.AbsSimpleCalc.PrFst $1 }
       | Proof1 '.snd' { Parser.AbsSimpleCalc.PrSnd $1 }
       | Proof1 '.out' { Parser.AbsSimpleCalc.PrOut $1 }
       | Proof3 { $1 }
Proof :: { (Proof ()) }
Proof : 'inst' Identifier ThmArgs { Parser.AbsSimpleCalc.PrThmInst $2 $3 }
      | Lambda Identifier '.' Proof { Parser.AbsSimpleCalc.PrImplIntro $1 $2 $4 }
      | '|inl' Proof1 { Parser.AbsSimpleCalc.PrOrIntroLeft $2 }
      | '|inr' Proof1 { Parser.AbsSimpleCalc.PrOrIntroRight $2 }
      | '|-elim' Proof4 Proof4 { Parser.AbsSimpleCalc.PrOrElim $2 $3 }
      | 'nec' Proof1 { Parser.AbsSimpleCalc.PrNec $2 }
      | 'fix' Identifier '.' Proof { Parser.AbsSimpleCalc.PrFP $2 $4 }
      | '\\\\' Identifier '.' Proof { Parser.AbsSimpleCalc.PrAllIntro $2 $4 }
      | 'ex' Term3 Proof1 { Parser.AbsSimpleCalc.PrExIntro $2 $3 }
      | 'ex-elim' Identifier Proof4 Proof4 { Parser.AbsSimpleCalc.PrExElim $2 $3 $4 }
      | 'refl' Term3 Term3 { Parser.AbsSimpleCalc.PrRefl $2 $3 }
      | 'sym' Proof4 { Parser.AbsSimpleCalc.PrSym $2 }
      | 'trans' Proof4 Proof4 { Parser.AbsSimpleCalc.PrTrans $2 $3 }
      | 'ext' Identifier Proof { Parser.AbsSimpleCalc.PrExt $2 $3 }
      | 'fun' Proof1 Term3 { Parser.AbsSimpleCalc.PrFunEq $2 $3 }
      | 'unit' Term3 { Parser.AbsSimpleCalc.PrUnit $2 }
      | 'coind' Proof1 { Parser.AbsSimpleCalc.PrCoind $2 }
      | '{' '<>' '->' Proof '}' Identifier { Parser.AbsSimpleCalc.PrUnitInd $4 $6 }
      | 'inl' Proof1 { Parser.AbsSimpleCalc.PrInl $2 }
      | 'inr' Proof1 { Parser.AbsSimpleCalc.PrInr $2 }
      | '{' 'inl' Identifier '->' Proof ';' 'inr' Identifier '->' Proof '}' Identifier { Parser.AbsSimpleCalc.PrSumInd $3 $5 $8 $10 $12 }
      | 'in' Proof1 { Parser.AbsSimpleCalc.PrIn $2 }
      | '{' 'in' Identifier '->' Proof '}' Identifier { Parser.AbsSimpleCalc.PrLfpInd $3 $5 $7 }
      | Proof1 { $1 }
Proof3 :: { Proof () }
Proof3 : Proof3 Proof4 { Parser.AbsSimpleCalc.PrImplElim $1 $2 }
       | Proof4 { $1 }
Proof1 :: { Proof () }
Proof1 : Proof2 { $1 }
ThmDecl :: { ThmDecl }
ThmDecl : Identifier PropDecls { Parser.AbsSimpleCalc.ThmDecl $1 $2 }
ThmDecls :: { ThmDecls }
ThmDecls : {- empty -} { Parser.AbsSimpleCalc.NoDeclArgs }
         | '[' ListThmDecl ']' { Parser.AbsSimpleCalc.DeclArgs $2 }
ListThmDecl :: { [ThmDecl] }
ListThmDecl : {- empty -} { [] }
            | ThmDecl { (:[]) $1 }
            | ThmDecl ',' ListThmDecl { (:) $1 $3 }
Entry :: { (Entry ()) }
Entry : 'type' Identifier '=' Type { Parser.AbsSimpleCalc.TypeDef $2 $4 }
      | Identifier ':' Type '=' Term { Parser.AbsSimpleCalc.Def $1 $3 $5 }
      | 'thm' Identifier ThmDecls ':' Formula '=' Proof { Parser.AbsSimpleCalc.Theorem $2 $3 $5 $7 }
      | 'def' Identifier ThmDecls '=' Formula { Parser.AbsSimpleCalc.FormDef $2 $3 $5 }
Program :: { (Program ()) }
Program : ListEntry { Parser.AbsSimpleCalc.Program (reverse $1) }
ListEntry :: { [Entry ()] }
ListEntry : {- empty -} { [] }
          | ListEntry Entry ';' { flip (:) $1 $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

