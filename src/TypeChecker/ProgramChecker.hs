{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE FlexibleContexts, FlexibleInstances #-}
module TypeChecker.ProgramChecker where

-- Haskell module generated by the BNF converter

import Data.Map as Map
import Data.Maybe as Data.Maybe

import Control.Applicative
import Control.Monad.State
import Control.Monad.Except
import Control.Monad.Reader
import Control.Monad.Writer
import Control.Monad.Trans.Class
import Control.Arrow

import Parser.AbsSimpleCalc
import Parser.PrintSimpleCalc

import TypeChecker.TyErr
import TypeChecker.Substitution
import TypeChecker.CheckMonad
import TypeChecker.TypeChecker
import TypeChecker.TypeCheck
import TypeChecker.ProofChecker

checkEntry :: Entry () -> CheckM ()
checkEntry x = case x of
   TypeDef name t -> safeTypeDecl name t
   Def name a t -> safeDecl name a t
   Theorem x thmdecls f p -> safeThmDecl x thmdecls f p
   FormDef p thmdecls f -> safeDef p thmdecls f

checkProgram :: Program () -> CheckM ()
checkProgram (Program entries) = foldM (\_ -> checkEntry) () entries

instance Checkable (Program ()) where
  check = checkProgram
